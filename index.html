<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2D kollision i planet</title>
  <style>
    body {margin:0;font-family:system-ui,Arial,sans-serif;background:#121212;color:#e0e0e0;}
    .wrap {display:flex;height:100vh;}
    .left {width:40%;padding:12px;border-right:1px solid #333;box-sizing:border-box;overflow:auto;background:#1e1e1e;}
    .right {width:60%;padding:12px;box-sizing:border-box;overflow:auto;background:#1e1e1e;display:flex;flex-direction:column;gap:10px;}
    .author-note {text-align: center;font-size: 0.8rem;opacity: 0.6;margin-bottom: 6px;}

    h2,h3{margin:10px 0;}
    .row {display:flex;gap:8px;flex-wrap:wrap;align-items:end;margin:10px 0;}
    label {font-size:0.85rem;opacity:0.95;display:flex;flex-direction:column;gap:4px;}
    input {width:140px;box-sizing:border-box;background:#2a2a2a;color:#e0e0e0;border:1px solid #444;padding:8px;border-radius:6px;}
    input.small{width:110px;}
    button {padding:10px 14px;background:#333;color:#e0e0e0;border:1px solid #555;cursor:pointer;border-radius:8px;}
    button:hover {background:#444;}
    button:disabled{opacity:0.6;cursor:not-allowed;}

    #status {font-size:0.9rem;opacity:0.9;}
    .card {border:1px solid #333;background:#181818;border-radius:10px;padding:10px;margin:10px 0;}
    .puck-list {display:flex;flex-direction:column;gap:8px;}
    .puck-item {display:flex;justify-content:space-between;gap:10px;align-items:center;border:1px solid #333;background:#171717;border-radius:10px;padding:8px;}
    .puck-item code {font-size:0.85rem;opacity:0.95;}
    .hint {font-size:0.9rem;opacity:0.9;}

    #simArea {flex:1;border:1px solid #333;background:#111;border-radius:12px;display:grid;place-items:center;overflow:hidden;padding:10px;}
    #simArea img {max-width:100%;height:auto;display:block;border-radius:10px;}
    .topbar {display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="left">
      <div class="author-note">Utvecklat av Joel Utsi & Linus Andersson</div>
      <h2>Puckdata</h2>

      <div class="row">
        <button id="simulateBtn" disabled>Simulera!</button>
        <span id="status">Laddar Python…</span>
      </div>

      <div class="card">
        <h3>Rum</h3>
        <div class="row">
          <label>
            Friktion (μ)
            <input id="friction" type="number" step="0.01" value="0.10" />
          </label>

          <label>
            Stöttal (e)
            <input id="cor" type="number" step="0.01" value="0.30" />
          </label>

          <label>
            Simuleringstid (s)
            <input id="T" type="number" step="0.1" value="5.0" />
          </label>
        </div>
        <div class="row">
          <label style="flex-direction:row;align-items:center;gap:6px;">
            <input id="borderEnabled" type="checkbox" style="width:auto;" />
            Kant
          </label>
          <label style="flex-direction:row;align-items:center;gap:8px;">
            <span style="font-size:0.85rem;opacity:0.95;">1D</span>
            <input id="dimensionMode" type="checkbox" checked style="width:auto;" />
            <span style="font-size:0.85rem;opacity:0.95;">2D</span>
          </label>
        </div>
        <div id="borderInputs" class="row" style="display:none;">
          <label>
            Bredd
            <input id="borderWidth" type="number" step="0.1" value="4.0" />
          </label>
          <label id="borderHeightLabel">
            Höjd
            <input id="borderHeight" type="number" step="0.1" value="4.0" />
          </label>
        </div>
      </div>

      <div class="card">
        <h3>Puck</h3>
        <div class="row">
          <label>pos x <input id="px" class="small" type="number" step="0.1" value="-1.0"></label>
          <label id="pyLabel">pos y <input id="py" class="small" type="number" step="0.1" value="-1.0"></label>
          <label>radie <input id="pr" class="small" type="number" step="0.01" value="0.15"></label>
          <label>massa <input id="pm" class="small" type="number" step="0.01" value="1.0"></label>
          <label>vx <input id="pvx" class="small" type="number" step="0.1" value="2.0"></label>
          <label id="pvyLabel">vy <input id="pvy" class="small" type="number" step="0.1" value="2.0"></label>

          <button id="addPuckBtn">Lägg till puck</button>
        </div>
        <div class="hint">Lägger till puck med position, radie, massa, och begynnelsehastighet.</div>

        <h3 style="margin-top:12px;">Puckar</h3>
        <div id="puckList" class="puck-list"></div>
      </div>
    </div>

    <div class="right">
      <div class="topbar">
        <h2 style="margin:0;">Simulation</h2>
        <div class="hint" id="simHint">Lägg till puckar och tryck på Simulera!</div>
        <button id="stopBtn" disabled>Stoppa</button>
      </div>

      <div id="simArea">
        <div class="hint">Inget att visa än.</div>
      </div>
    </div>
  </div>

  <!-- Pyodide -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.js"></script>

  <script>
    const statusEl = document.getElementById("status");
    const simulateBtn = document.getElementById("simulateBtn");
    const stopBtn = document.getElementById("stopBtn");
    const addPuckBtn = document.getElementById("addPuckBtn");
    const puckListEl = document.getElementById("puckList");
    const simHintEl = document.getElementById("simHint");
    const simAreaEl = document.getElementById("simArea");
    const borderEnabledEl = document.getElementById("borderEnabled");
    const borderInputsEl = document.getElementById("borderInputs");
    const dimensionModeEl = document.getElementById("dimensionMode");
    const pyLabelEl = document.getElementById("pyLabel");
    const pvyLabelEl = document.getElementById("pvyLabel");
    const borderHeightLabelEl = document.getElementById("borderHeightLabel");

    let pyodide = null;
    let pucks = [];

    function isFiniteNumber(x){ return Number.isFinite(x); }
    function readNum(id){
      const v = Number(document.getElementById(id).value);
      return isFiniteNumber(v) ? v : null;
    }

    function renderPuckList(){
      puckListEl.innerHTML = "";
      if (pucks.length === 0){
        puckListEl.innerHTML = `<div class="hint">Inga puckar än.</div>`;
        return;
      }
      pucks.forEach((p, idx) => {
        const div = document.createElement("div");
        div.className = "puck-item";
        div.innerHTML = `
          <code>
            #${idx+1} pos=(${p.x.toFixed(2)}, ${p.y.toFixed(2)})
            r=${p.radius.toFixed(2)} m=${p.mass.toFixed(2)}
            v=(${p.vx.toFixed(2)}, ${p.vy.toFixed(2)})
          </code>
          <button data-remove="${idx}">Ta bort</button>
        `;
        div.querySelector("button").addEventListener("click", () => {
          pucks.splice(idx, 1);
          renderPuckList();
        });
        puckListEl.appendChild(div);
      });
    }

    addPuckBtn.addEventListener("click", () => {
      const is1D = !dimensionModeEl.checked;
      const x = readNum("px"), y = is1D ? 0 : readNum("py"), radius = readNum("pr"),
            mass = readNum("pm"),
            vx = readNum("pvx"), vy = is1D ? 0 : readNum("pvy");

      const vals = is1D ? [x,radius,mass,vx] : [x,y,radius,mass,vx,vy];
      if (vals.some(v => v === null)){
        statusEl.textContent = "Fyll i alla puck-fält med giltiga tal.";
        return;
      }
      if (radius <= 0 || mass <= 0){
        statusEl.textContent = "Radie och massa måste vara > 0.";
        return;
      }

      pucks.push({x,y,radius,mass,vx,vy});
      renderPuckList();
      statusEl.textContent = "Puck tillagd.";
    });

    async function initPyodideAndPackages(){
      statusEl.textContent = "Laddar Python runtime…";
      pyodide = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.29.0/full/" });

      statusEl.textContent = "Laddar numpy + matplotlib + pillow…";
      await pyodide.loadPackage(["numpy", "matplotlib", "pillow"]);

      pyodide.runPython(`
import math, base64, os
import numpy as np
from io import BytesIO
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from matplotlib.animation import FuncAnimation, PillowWriter
from PIL import Image

class Puck:
    def __init__(self, pos, radius, mass):
        self.pos = pos
        self.radius = radius
        self.mass = mass
        self.velocity = (0.0, 0.0)

    def set_position(self, pos):
        self.pos = pos

    def set_velocity(self, vx, vy):
        self.velocity = (float(vx), float(vy))

    def get_velocity(self):
        return self.velocity

    def get_pos(self):
        return self.pos

    def get_radius(self):
        return self.radius

    def get_mass(self):
        return self.mass

class Room:
    def __init__(self, friction, cor):
        self.friction = float(friction)
        self.cor = float(cor)
        self.pucks = []
        self.border = None

    def set_border(self, width, height):
        self.border = {"width": float(width), "height": float(height)}

    def add(self, puck):
        self.pucks.append(puck)

    def update_step(self, dt):
        length = len(self.pucks)

        for i in range(length):
            for j in range(i + 1, length):
                p1, p2 = self.pucks[i], self.pucks[j]
                if self.collision(p1, p2):
                    v1_after, v2_after = self.collision_velocities(p1, p2)
                    p1.set_velocity(*v1_after)
                    p2.set_velocity(*v2_after)

                    n = self.collision_normal(p1, p2)
                    d = self.distance(p1, p2)
                    collision_radius = p1.get_radius() + p2.get_radius()
                    dist = math.sqrt(self._prod(d, d))
                    extra_margin = (collision_radius - dist) if dist > 0 else collision_radius
                    p1.set_position(self._sum(p1.get_pos(), self._mult_scalar(extra_margin, n)))
                    p2.set_position(self._sum(p2.get_pos(), self._mult_scalar(-extra_margin, n)))

        if self.border:
            for puck in self.pucks:
                self._handle_border_collision(puck)

        for puck in self.pucks:
            vx, vy = puck.get_velocity()
            x, y = puck.get_pos()

            new_pos = (x + dt * vx, y + dt * vy)

            ax, ay = self._deceleration(puck)
            new_v = (vx - dt * ax, vy - dt * ay)

            puck.set_position(new_pos)
            puck.set_velocity(*new_v)

    def _handle_border_collision(self, puck):
        x, y = puck.get_pos()
        vx, vy = puck.get_velocity()
        r = puck.get_radius()
        w = self.border["width"] / 2.0
        h = self.border["height"] / 2.0
        e = self.cor

        if x - r < -w:
            puck.set_position((-w + r, y))
            puck.set_velocity(-vx * e, vy)
        elif x + r > w:
            puck.set_position((w - r, y))
            puck.set_velocity(-vx * e, vy)

        x, y = puck.get_pos()
        vx, vy = puck.get_velocity()

        if y - r < -h:
            puck.set_position((x, -h + r))
            puck.set_velocity(vx, -vy * e)
        elif y + r > h:
            puck.set_position((x, h - r))
            puck.set_velocity(vx, -vy * e)

    def collision_velocities(self, p1, p2):
        m1, m2 = p1.get_mass(), p2.get_mass()
        e = self.cor
        n = self.collision_normal(p1, p2)
        v1, v2 = p1.get_velocity(), p2.get_velocity()
        return self._collision_equations(m1, m2, e, n, v1, v2)

    def _collision_equations(self, m1, m2, e, n, v1, v2):
        rel = self._diff(v1, v2)
        k = self._prod(rel, n)
        v1_after = self._diff(v1, self._mult_scalar((1 + e) * m2 / (m1 + m2) * k, n))
        v2_after = self._sum(v2, self._mult_scalar((1 + e) * m1 / (m1 + m2) * k, n))
        return v1_after, v2_after

    def collision_normal(self, p1, p2):
        d = self.distance(p1, p2)
        norm = math.sqrt(self._prod(d, d))
        return self._div(d, norm)

    def distance(self, p1, p2):
        return self._diff(p1.get_pos(), p2.get_pos())

    def collision(self, p1, p2):
        d = self.distance(p1, p2)
        r = p1.get_radius() + p2.get_radius()
        return self._prod(d, d) < r * r

    def _deceleration(self, puck):
        g = 9.82
        vx, vy = puck.get_velocity()
        speed = math.sqrt(vx*vx + vy*vy)
        if speed == 0.0:
            return (0.0, 0.0)
        dir_v = (vx / speed, vy / speed)
        return self._mult_scalar(self.friction * g, dir_v)

    def _prod(self, a, b):
        return a[0]*b[0] + a[1]*b[1]
    def _diff(self, a, b):
        return (a[0]-b[0], a[1]-b[1])
    def _sum(self, a, b):
        return (a[0]+b[0], a[1]+b[1])
    def _mult_scalar(self, s, v):
        return (s*v[0], s*v[1])
    def _div(self, v, s):
        if s == 0.0:
            return (0.0, 0.0)
        return (v[0]/s, v[1]/s)

DT = 0.002
FPS = 24

def simulate_to_media_base64(pucks_data, friction, cor, T, border_enabled, border_width, border_height):
    dt = DT
    fps = FPS
    T = float(T)
    friction = float(friction)
    cor = float(cor)

    room = Room(friction, cor)
    if border_enabled:
        room.set_border(border_width, border_height)
    pucks = []
    for p in pucks_data:
        puck = Puck(
            (float(p["x"]), float(p["y"])),
            float(p["radius"]),
            float(p["mass"]),
        )
        puck.set_velocity(float(p["vx"]), float(p["vy"]))
        room.add(puck)
        pucks.append(puck)

    steps = int(max(1, math.ceil(T / dt)))

    target_frames = max(1, int(T * fps))
    k = max(1, steps // target_frames)

    frames_pos = []
    frames_vel = []
    for s in range(steps + 1):
        if s % k == 0:
            frames_pos.append([p.get_pos() for p in pucks])
            frames_vel.append([p.get_velocity() for p in pucks])
        room.update_step(dt)

    radii = [p.get_radius() for p in pucks]

    xmin = ymin = float("inf")
    xmax = ymax = float("-inf")
    for fr in frames_pos:
        for i, (x, y) in enumerate(fr):
            r = radii[i]
            xmin = min(xmin, x - r); xmax = max(xmax, x + r)
            ymin = min(ymin, y - r); ymax = max(ymax, y + r)
    
    if border_enabled:
        bw = float(border_width) / 2.0
        bh = float(border_height) / 2.0
        xmin = min(xmin, -bw); xmax = max(xmax, bw)
        ymin = min(ymin, -bh); ymax = max(ymax, bh)
    
    span = max(xmax - xmin, ymax - ymin, 1.0)
    pad = 0.12 * span
    xmin -= pad; xmax += pad; ymin -= pad; ymax += pad

    fig, ax = plt.subplots(figsize=(6.4, 4.0), dpi=140)
    bg = "#0f1115"
    fig.patch.set_facecolor(bg)
    ax.set_facecolor(bg)

    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)
    ax.set_aspect("equal", adjustable="box")

    ax.set_xticks([]); ax.set_yticks([])
    for sp in ax.spines.values():
        sp.set_visible(False)

    if border_enabled:
        from matplotlib.patches import Rectangle
        bw = float(border_width) / 2.0
        bh = float(border_height) / 2.0
        border_rect = Rectangle((-bw, -bh), border_width, border_height, 
                                fill=False, linewidth=1.8, edgecolor="#888888", alpha=0.7)
        ax.add_patch(border_rect)

    circles = []
    for i in range(len(pucks)):
        c = Circle((0, 0), radii[i], fill=False, linewidth=2.2, edgecolor="#e6e6e6", alpha=0.95)
        ax.add_patch(c)
        circles.append(c)

    label_offset = 0.02 * span 

    texts = []
    for i in range(len(pucks)):
        t = ax.text(
            0, 0, f"P{i+1}",
            ha="center", va="bottom",
            fontsize=9,
            color="#eaeaea",
            family="sans-serif",
            weight="bold",
        )
        texts.append(t)

    hud = ax.text(
        0.02, 0.02, "",
        transform=ax.transAxes,
        va="bottom", ha="left",
        fontsize=7,
        color="#eaeaea",
        family="monospace",
        bbox=dict(
            boxstyle="round,pad=0.25",
            facecolor=(0,0,0,0.22),
            edgecolor=(1,1,1,0.10)
        )
    )

    def init():
        if len(frames_pos) > 0:
            for i, (x, y) in enumerate(frames_pos[0]):
                circles[i].center = (x, y)
                texts[i].set_position((x, y + radii[i] + label_offset))
        hud.set_text("")
        return circles + texts + [hud]

    def update(frame_idx):
        pos = frames_pos[frame_idx]
        vel = frames_vel[frame_idx]

        for i, (x, y) in enumerate(pos):
            circles[i].center = (x, y)
            texts[i].set_position((x, y + radii[i] + label_offset))

        lines = []
        for i, ((x, y), (vx, vy)) in enumerate(zip(pos, vel), start=1):
            lines.append(f"P{i}: x={x:+.2f} y={y:+.2f}  vx={vx:+.2f} vy={vy:+.2f}")

        hud.set_text("\\n".join(lines))
        return circles + texts + [hud]

    anim = FuncAnimation(
        fig,
        update,
        init_func=init,
        frames=len(frames_pos),
        interval=1000 / fps,
        blit=True,
    )

    out_path = "/tmp/sim.gif"
    writer = PillowWriter(fps=fps)
    anim.save(out_path, writer=writer)
    plt.close(fig)

    with open(out_path, "rb") as f:
        gif_bytes = f.read()

    try:
        os.remove(out_path)
    except Exception:
        pass

    duration_ms = int(len(frames_pos) * (1000 / fps))

    return {
        "gif_b64": base64.b64encode(gif_bytes).decode("utf-8"),
        "last_png_b64": "",
        "duration_ms": duration_ms
    }
      `);

      statusEl.textContent = "Redo.";
      simulateBtn.disabled = false;
    }

    simulateBtn.addEventListener("click", () => {
      doSimulate().catch(err => {
        statusEl.textContent = "Fel.";
        simHintEl.textContent = err?.message || String(err);
      });
    });

    stopBtn.addEventListener("click", () => {
      simAreaEl.innerHTML = `<div class="hint">Inget att visa än.</div>`;
      simHintEl.textContent = "Lägg till puckar och tryck på Simulera!";
      statusEl.textContent = "Redo.";
      stopBtn.disabled = true;
    });

    borderEnabledEl.addEventListener("change", () => {
      borderInputsEl.style.display = borderEnabledEl.checked ? "flex" : "none";
    });

    dimensionModeEl.addEventListener("change", () => {
      const is1D = !dimensionModeEl.checked;
      pyLabelEl.style.display = is1D ? "none" : "flex";
      pvyLabelEl.style.display = is1D ? "none" : "flex";
      if (borderEnabledEl.checked) {
        borderHeightLabelEl.style.display = is1D ? "none" : "flex";
      }
    });

    let lastFreezeTimer = null;
    let simRunId = 0;

    async function doSimulate(){
      if (!pyodide) return;
      if (pucks.length === 0){
        statusEl.textContent = "Lägg till åtminstone en puck.";
        return;
      }

      const friction = readNum("friction");
      const cor = readNum("cor");
      const T = readNum("T");
      const borderEnabled = borderEnabledEl.checked;
      const borderWidth = borderEnabled ? readNum("borderWidth") : null;
      const borderHeight = borderEnabled ? readNum("borderHeight") : null;

      if ([friction, cor, T].some(v => v === null)){
        statusEl.textContent = "Fyll i friction/e/T med giltiga tal.";
        return;
      }
      if (borderEnabled && (borderWidth === null || borderHeight === null)){
        statusEl.textContent = "Fyll i kant bredd och höjd.";
        return;
      }
      if (borderEnabled && (borderWidth <= 0 || borderHeight <= 0)){
        statusEl.textContent = "Kant bredd och höjd måste vara > 0.";
        return;
      }
      if (friction < 0){
        statusEl.textContent = "Friktionen måste vara >= 0.";
        return;
      }
      if (cor < 0 || cor > 1){
        statusEl.textContent = "e är i intervallet [0, 1].";
        return;
      }
      if (T <= 0){
        statusEl.textContent = "T måste vara > 0.";
        return;
      }

      simRunId += 1;
      const runId = simRunId;

      if (lastFreezeTimer) {
        clearTimeout(lastFreezeTimer);
        lastFreezeTimer = null;
      }

      simulateBtn.disabled = true;
      statusEl.textContent = "Simulerar + renderar GIF...";
      simHintEl.textContent = "Simulerar i Matplotlib...";

      simAreaEl.innerHTML = `<div class="hint">Renderar…</div>`;

      pyodide.globals.set("pucks_js", pyodide.toPy(pucks));
      pyodide.globals.set("friction_js", friction);
      pyodide.globals.set("cor_js", cor);
      pyodide.globals.set("T_js", T);
      pyodide.globals.set("border_enabled_js", borderEnabled);
      pyodide.globals.set("border_width_js", borderWidth || 0);
      pyodide.globals.set("border_height_js", borderHeight || 0);

      const pyRes = await pyodide.runPythonAsync(
        "simulate_to_media_base64(pucks_js, friction_js, cor_js, T_js, border_enabled_js, border_width_js, border_height_js)"
      );

      if (runId !== simRunId) {
        try { pyRes.destroy(); } catch(e) {}
        return;
      }

      const res = pyRes.toJs({ dict_converter: Object.fromEntries });
      try { pyRes.destroy(); } catch(e) {}

      const gifB64 = res.gif_b64;

      simAreaEl.innerHTML = `<img id="simImg" alt="Simulation GIF" src="data:image/gif;base64,${gifB64}">`;

      statusEl.textContent = "Klar.";
      simHintEl.textContent = "Tryck Simulera! för ny simulering.";
      simulateBtn.disabled = false;
      stopBtn.disabled = false;
    }

    renderPuckList();
    initPyodideAndPackages().catch(err => {
      statusEl.textContent = "Lyckades inte ladda Python.";
      simHintEl.textContent = err?.message || String(err);
    });
  </script>
</body>
</html>
