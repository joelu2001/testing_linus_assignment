<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2D kollision i planet</title>
  <style>
    body {margin:0;font-family:system-ui,Arial,sans-serif;background:#121212;color:#e0e0e0;}
    .wrap {display:flex;height:100vh;}
    .left {width:40%;padding:12px;border-right:1px solid #333;box-sizing:border-box;overflow:auto;background:#1e1e1e;}
    .right {width:60%;padding:12px;box-sizing:border-box;overflow:auto;background:#1e1e1e;display:flex;flex-direction:column;gap:10px;}
    .author-note {text-align: center;font-size: 0.8rem;opacity: 0.6;margin-bottom: 6px;}

    h2,h3{margin:10px 0;}
    .row {display:flex;gap:8px;flex-wrap:wrap;align-items:end;margin:10px 0;}
    label {font-size:0.85rem;opacity:0.95;display:flex;flex-direction:column;gap:4px;}
    input {width:140px;box-sizing:border-box;background:#2a2a2a;color:#e0e0e0;border:1px solid #444;padding:8px;border-radius:6px;}
    input.small{width:110px;}
    button {padding:10px 14px;background:#333;color:#e0e0e0;border:1px solid #555;cursor:pointer;border-radius:8px;}
    button:hover {background:#444;}
    button:disabled{opacity:0.6;cursor:not-allowed;}

    #status {font-size:0.9rem;opacity:0.9;}
    .card {border:1px solid #333;background:#181818;border-radius:10px;padding:10px;margin:10px 0;}
    .puck-list {display:flex;flex-direction:column;gap:8px;}
    .puck-item {display:flex;justify-content:space-between;gap:10px;align-items:center;border:1px solid #333;background:#171717;border-radius:10px;padding:8px;}
    .puck-item code {font-size:0.85rem;opacity:0.95;}
    .danger {border-color:#7f1d1d;}
    .hint {font-size:0.9rem;opacity:0.9;}

    #simArea {flex:1;border:1px solid #333;background:#111;border-radius:12px;display:grid;place-items:center;overflow:hidden;}
    canvas {max-width:100%;height:auto;display:block;}
    .topbar {display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="left">
	<div class="author-note">
		Utvecklat av Joel Utsi & Linus Andersson
	</div>
      <h2>Puckdata</h2>

      <div class="row">
        <button id="simulateBtn" disabled>Simulera!</button>
        <span id="status">Laddar Python…</span>
      </div>

      <div class="card">
        <h3>Rum</h3>
        <div class="row">
          <label>
            Friktion (μ)
            <input id="friction" type="number" step="0.01" value="0.10" />
          </label>

          <label>
            Simuleringstid (s)
            <input id="T" type="number" step="0.1" value="5.0" />
          </label>
        </div>
      </div>

      <div class="card">
        <h3>Puck</h3>
        <div class="row">
          <label>pos x <input id="px" class="small" type="number" step="0.1" value="-1.0"></label>
          <label>pos y <input id="py" class="small" type="number" step="0.1" value="-1.0"></label>
          <label>radie <input id="pr" class="small" type="number" step="0.01" value="0.15"></label>
          <label>massa <input id="pm" class="small" type="number" step="0.01" value="1.0"></label>
          <label>e <input id="pcor" class="small" type="number" step="0.01" value="0.30"></label>
          <label>vx <input id="pvx" class="small" type="number" step="0.1" value="2.0"></label>
          <label>vy <input id="pvy" class="small" type="number" step="0.1" value="2.0"></label>

          <button id="addPuckBtn">Lägg till puck</button>
        </div>
        <div class="hint">Lägger till puck med position, radie, massa, stöttal, och begynnelsehastighet.</div>

        <h3 style="margin-top:12px;">Puckar</h3>
        <div id="puckList" class="puck-list"></div>
      </div>
    </div>

    <div class="right">
      <div class="topbar">
        <h2 style="margin:0;">Simulation</h2>
        <div class="hint" id="simHint">Lägg till puckar och tryck på Simulera!.</div>
      </div>

      <div id="simArea">
        <canvas id="canvas" width="900" height="600"></canvas>
      </div>
    </div>
  </div>

  <!-- Pyodide -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.js"></script>

  <script>
    const statusEl = document.getElementById("status");
    const simulateBtn = document.getElementById("simulateBtn");
    const addPuckBtn = document.getElementById("addPuckBtn");
    const puckListEl = document.getElementById("puckList");
    const simHintEl = document.getElementById("simHint");

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    let pyodide = null;
    let pucks = []; // JS list of puck definitions

    // Animation state
	let frames = null;      // array: frames[frameIndex] = [[x,y], [x,y], ...]
	let radii = null;       // array: radii[i]
	let frameIndex = 0;
	let rafId = null;
    let worldBounds = {xmin:-2, xmax:2, ymin:-2, ymax:2}; // simple default

    function isFiniteNumber(x){ return Number.isFinite(x); }
    function readNum(id){
      const v = Number(document.getElementById(id).value);
      return isFiniteNumber(v) ? v : null;
    }

    function renderPuckList(){
      puckListEl.innerHTML = "";
      if (pucks.length === 0){
        puckListEl.innerHTML = `<div class="hint">Inga puckar än.</div>`;
        return;
      }
      pucks.forEach((p, idx) => {
        const div = document.createElement("div");
        div.className = "puck-item";
        div.innerHTML = `
          <code>
            #${idx+1} pos=(${p.x.toFixed(2)}, ${p.y.toFixed(2)})
            r=${p.radius.toFixed(2)} m=${p.mass.toFixed(2)} cor=${p.cor.toFixed(2)}
            v=(${p.vx.toFixed(2)}, ${p.vy.toFixed(2)})
          </code>
          <button data-remove="${idx}">Ta bort</button>
        `;
        div.querySelector("button").addEventListener("click", () => {
          pucks.splice(idx, 1);
          renderPuckList();
        });
        puckListEl.appendChild(div);
      });
    }

    addPuckBtn.addEventListener("click", () => {
      const x = readNum("px"), y = readNum("py"), radius = readNum("pr"),
            mass = readNum("pm"), cor = readNum("pcor"),
            vx = readNum("pvx"), vy = readNum("pvy");

      const vals = [x,y,radius,mass,cor,vx,vy];
      if (vals.some(v => v === null)){
        statusEl.textContent = "Fyll i alla puck-fält med giltiga tal.";
        return;
      }
      if (radius <= 0 || mass <= 0){
        statusEl.textContent = "Radie och massa måste vara > 0.";
        return;
      }
      if (cor < 0 || cor > 1){
        statusEl.textContent = "e är i intervallet [0, 1].";
        return;
      }

      pucks.push({x,y,radius,mass,cor,vx,vy});
      renderPuckList();
      statusEl.textContent = "Puck tillagd.";
    });

    function clearAnimation(){
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      frames = null;
      radii = null;
      frameIndex = 0;
      draw(); // draw empty
    }

    function worldToCanvas(x, y){
      const {xmin,xmax,ymin,ymax} = worldBounds;
      const w = canvas.width, h = canvas.height;
      const sx = (x - xmin) / (xmax - xmin) * w;
      const sy = h - (y - ymin) / (ymax - ymin) * h;
      return [sx, sy];
    }

    function radiusToCanvas(r){
      const {xmin,xmax} = worldBounds;
      const w = canvas.width;
      return r / (xmax - xmin) * w;
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width, canvas.height);

      // background grid (simple)
      ctx.globalAlpha = 0.18;
      ctx.beginPath();
      const step = 50;
      for (let x=0; x<=canvas.width; x+=step){ ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
      for (let y=0; y<=canvas.height; y+=step){ ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
      ctx.strokeStyle = "#ffffff";
      ctx.stroke();
      ctx.globalAlpha = 1;

      if (!frames || frameIndex >= frames.length) return;

      const frame = frames[frameIndex];
      for (let i=0; i<frame.length; i++){
        const [x,y] = frame[i];
        const [cx,cy] = worldToCanvas(x,y);
        const rr = radiusToCanvas(radii[i]);

        ctx.beginPath();
        ctx.arc(cx, cy, rr, 0, Math.PI*2);
        ctx.strokeStyle = "#e0e0e0";
        ctx.lineWidth = 2;
        ctx.stroke();

        // small center dot
        ctx.beginPath();
        ctx.arc(cx, cy, 2.5, 0, Math.PI*2);
        ctx.fillStyle = "#e0e0e0";
        ctx.fill();
      }
    }

	const FPS = 60;
	const FRAME_MS = 1000 / FPS;
	let lastTs = 0;

	function animate(ts) {
	if (!frames || frames.length === 0) return;

	if (!lastTs) lastTs = ts;
	const elapsed = ts - lastTs;

	// how many frames should we advance?
	const advance = Math.floor(elapsed / FRAME_MS);

	if (advance > 0) {
		frameIndex += advance;
		lastTs += advance * FRAME_MS;

		if (frameIndex >= frames.length) {
		frameIndex = frames.length - 1;
		draw();
		rafId = null;
		statusEl.textContent = "Klar.";
		return;
		}

		draw();
	}

	rafId = requestAnimationFrame(animate);
	}

	function startAnimation() {
	if (rafId !== null) cancelAnimationFrame(rafId);
	rafId = null;
	frameIndex = 0;
	lastTs = 0;
	statusEl.textContent = "Simulerar...";
	rafId = requestAnimationFrame(animate);
	}

    async function initPyodideAndPackages(){
      statusEl.textContent = "Laddar Python runtime…";
      pyodide = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.29.0/full/" });

      statusEl.textContent = "Laddar numpy…";
      await pyodide.loadPackage(["numpy"]);

      // Define simulation code in Python (close to your reference).
      pyodide.runPython(`
import math

class Puck:
    def __init__(self, pos, radius, mass, cor):
        self.pos = pos
        self.radius = radius
        self.mass = mass
        self.cor = cor
        self.velocity = (0.0, 0.0)

    def set_position(self, pos):
        self.pos = pos

    def set_velocity(self, vx, vy):
        self.velocity = (float(vx), float(vy))

    def get_velocity(self):
        return self.velocity

    def get_pos(self):
        return self.pos

    def get_radius(self):
        return self.radius

    def get_mass(self):
        return self.mass

    def get_cor(self):
        return self.cor

class Room:
    def __init__(self, friction):
        self.friction = float(friction)
        self.pucks = []

    def add(self, puck):
        self.pucks.append(puck)

    def update_step(self, dt):
        length = len(self.pucks)

        # collisions
        for i in range(length):
            for j in range(i + 1, length):
                p1, p2 = self.pucks[i], self.pucks[j]
                if self.collision(p1, p2):
                    v1_after, v2_after = self.collision_velocities(p1, p2)
                    p1.set_velocity(*v1_after)
                    p2.set_velocity(*v2_after)

                    # separate overlap
                    n = self.collision_normal(p1, p2)
                    d = self.distance(p1, p2)
                    collision_radius = p1.get_radius() + p2.get_radius()
                    dist = math.sqrt(self._prod(d, d))
                    extra_margin = (collision_radius - dist) if dist > 0 else collision_radius
                    p1.set_position(self._sum(p1.get_pos(), self._mult_scalar(extra_margin, n)))
                    p2.set_position(self._sum(p2.get_pos(), self._mult_scalar(-extra_margin, n)))

        # integrate
        for puck in self.pucks:
            v = puck.get_velocity()
            pos = puck.get_pos()

            new_pos = self._sum(pos, self._mult_scalar(dt, v))
            a = self._deceleration(puck)
            new_v = self._diff(v, self._mult_scalar(dt, a))

            puck.set_position(new_pos)
            puck.set_velocity(*new_v)

    def collision_velocities(self, p1, p2):
        m1, m2 = p1.get_mass(), p2.get_mass()
        e = max(p1.get_cor(), p2.get_cor())
        n = self.collision_normal(p1, p2)
        v1, v2 = p1.get_velocity(), p2.get_velocity()
        return self._collision_equations(m1, m2, e, n, v1, v2)

    def _collision_equations(self, m1, m2, e, n, v1, v2):
        # same formula as your reference
        rel = self._diff(v1, v2)
        k = self._prod(rel, n)
        v1_after = self._diff(v1, self._mult_scalar((1 + e) * m2 / (m1 + m2) * k, n))
        v2_after = self._sum(v2, self._mult_scalar((1 + e) * m1 / (m1 + m2) * k, n))
        return v1_after, v2_after

    def collision_normal(self, p1, p2):
        d = self.distance(p1, p2)
        norm = math.sqrt(self._prod(d, d))
        return self._div(d, norm)

    def distance(self, p1, p2):
        return self._diff(p1.get_pos(), p2.get_pos())

    def collision(self, p1, p2):
        d = self.distance(p1, p2)
        r = p1.get_radius() + p2.get_radius()
        return self._prod(d, d) < r * r

    def _deceleration(self, puck):
        # friction deceleration magnitude mu*g, opposite velocity direction
        g = 9.82
        vx, vy = puck.get_velocity()
        speed = math.sqrt(vx*vx + vy*vy)
        if speed == 0.0:
            return (0.0, 0.0)
        dir_v = (vx / speed, vy / speed)
        return self._mult_scalar(self.friction * g, dir_v)

    def _prod(self, a, b):
        return a[0]*b[0] + a[1]*b[1]
    def _diff(self, a, b):
        return (a[0]-b[0], a[1]-b[1])
    def _sum(self, a, b):
        return (a[0]+b[0], a[1]+b[1])
    def _mult_scalar(self, s, v):
        return (s*v[0], s*v[1])
    def _div(self, v, s):
        if s == 0.0:
            return (0.0, 0.0)
        return (v[0]/s, v[1]/s)

DT = 0.002
FPS = 60

def simulate(pucks_data, friction, T):
    dt = DT
    fps = FPS
    T = float(T)
    friction = float(friction)

    room = Room(friction)
    pucks = []

    for p in pucks_data:
        puck = Puck(
            (float(p["x"]), float(p["y"])),
            float(p["radius"]),
            float(p["mass"]),
            float(p["cor"]),
        )
        puck.set_velocity(float(p["vx"]), float(p["vy"]))
        room.add(puck)
        pucks.append(puck)

    steps = int(max(1, math.ceil(T / dt)))

    # record frames so animation plays at ~60 fps
    target_frames = max(1, int(T * fps))
    k = max(1, steps // target_frames)

    frames = []
    for s in range(steps + 1):
        if s % k == 0:
            frames.append([list(p.get_pos()) for p in pucks])
        room.update_step(dt)

    radii = [p.get_radius() for p in pucks]
    return {"frames": frames, "radii": radii, "dt": dt, "fps": fps}
`);

      statusEl.textContent = "Redo.";
      simulateBtn.disabled = false;
    }

    simulateBtn.addEventListener("click", () => {
      doSimulate().catch(err => {
        statusEl.textContent = "Fel.";
        simHintEl.textContent = err?.message || String(err);
      });
    });

	async function doSimulate(){
	if (!pyodide) return;
	if (pucks.length === 0){
		statusEl.textContent = "Lägg till åtminstone en puck.";
		return;
	}

	const friction = readNum("friction");
	const T = readNum("T");

	if ([friction, T].some(v => v === null)){
		statusEl.textContent = "Fyll i friction/T med giltiga tal.";
		return;
	}
	if (friction < 0){
		statusEl.textContent = "Friktionen måste vara >= 0.";
		return;
	}
	if (T <= 0){
		statusEl.textContent = "T måste vara > 0.";
		return;
	}

	simulateBtn.disabled = true;
	statusEl.textContent = "Simulerar...";
	simHintEl.textContent = "Simulerar i Python, animerar i JS…";

	clearAnimation();

	pyodide.globals.set("pucks_js", pyodide.toPy(pucks));
	pyodide.globals.set("friction_js", friction);
	pyodide.globals.set("T_js", T);

	const out = pyodide.runPython("simulate(pucks_js, friction_js, T_js)").toJs();

	frames = out.frames;
	radii = out.radii;

	// bounds
	let xmin=Infinity, xmax=-Infinity, ymin=Infinity, ymax=-Infinity;
	for (const fr of frames){
		for (let i=0;i<fr.length;i++){
		const x = fr[i][0], y = fr[i][1], r = radii[i];
		xmin = Math.min(xmin, x - r);
		xmax = Math.max(xmax, x + r);
		ymin = Math.min(ymin, y - r);
		ymax = Math.max(ymax, y + r);
		}
	}
	const span = Math.max(xmax-xmin, ymax-ymin, 1.0);
	const pad = 0.10 * span;
	worldBounds = { xmin:xmin-pad, xmax:xmax+pad, ymin:ymin-pad, ymax:ymax+pad };

	startAnimation();

	simulateBtn.disabled = false;
	}

    // init
    renderPuckList();
    initPyodideAndPackages().catch(err => {
      statusEl.textContent = "Lyckades inte ladda Python.";
      simHintEl.textContent = err?.message || String(err);
    });
  </script>
</body>
</html>
