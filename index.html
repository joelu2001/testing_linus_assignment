<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2D kollision i planet</title>
  <style>
    body {margin:0;font-family:system-ui,Arial,sans-serif;background:#121212;color:#e0e0e0;}
    .wrap {display:flex;height:100vh;}
    .left {width:40%;padding:12px;border-right:1px solid #333;box-sizing:border-box;overflow:auto;background:#1e1e1e;}
    .right {width:60%;padding:12px;box-sizing:border-box;overflow:auto;background:#1e1e1e;display:flex;flex-direction:column;gap:10px;}
    .author-note {text-align: center;font-size: 0.8rem;opacity: 0.6;margin-bottom: 6px;}

    h2,h3{margin:10px 0;}
    .row {display:flex;gap:8px;flex-wrap:wrap;align-items:end;margin:10px 0;}
    label {font-size:0.85rem;opacity:0.95;display:flex;flex-direction:column;gap:4px;}
    input {width:140px;box-sizing:border-box;background:#2a2a2a;color:#e0e0e0;border:1px solid #444;padding:8px;border-radius:6px;}
    input.small{width:110px;}
    button {padding:10px 14px;background:#333;color:#e0e0e0;border:1px solid #555;cursor:pointer;border-radius:8px;}
    button:hover {background:#444;}
    button:disabled{opacity:0.6;cursor:not-allowed;}

    #status {font-size:0.9rem;opacity:0.9;}
    .card {border:1px solid #333;background:#181818;border-radius:10px;padding:10px;margin:10px 0;}
    .puck-list {display:flex;flex-direction:column;gap:8px;}
    .puck-item {display:flex;justify-content:space-between;gap:10px;align-items:center;border:1px solid #333;background:#171717;border-radius:10px;padding:8px;}
    .puck-item code {font-size:0.85rem;opacity:0.95;}
    .hint {font-size:0.9rem;opacity:0.9;}

    #simArea {flex:1;border:1px solid #333;background:#111;border-radius:12px;display:grid;place-items:center;overflow:hidden;padding:10px;}
    #simArea img {max-width:100%;height:auto;display:block;border-radius:10px;}
    .topbar {display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="left">
      <div class="author-note">Utvecklat av Joel Utsi & Linus Andersson</div>
      <h2>Puckdata</h2>

      <div class="row">
        <button id="simulateBtn" disabled>Simulera!</button>
        <span id="status">Laddar Python…</span>
      </div>

      <div class="card">
        <h3>Rum</h3>
        <div class="row">
          <label>
            Friktion (μ)
            <input id="friction" type="number" step="0.01" value="0.10" />
          </label>

          <label>
            Simuleringstid (s)
            <input id="T" type="number" step="0.1" value="5.0" />
          </label>
        </div>
      </div>

      <div class="card">
        <h3>Puck</h3>
        <div class="row">
          <label>pos x <input id="px" class="small" type="number" step="0.1" value="-1.0"></label>
          <label>pos y <input id="py" class="small" type="number" step="0.1" value="-1.0"></label>
          <label>radie <input id="pr" class="small" type="number" step="0.01" value="0.15"></label>
          <label>massa <input id="pm" class="small" type="number" step="0.01" value="1.0"></label>
          <label>e <input id="pcor" class="small" type="number" step="0.01" value="0.30"></label>
          <label>vx <input id="pvx" class="small" type="number" step="0.1" value="2.0"></label>
          <label>vy <input id="pvy" class="small" type="number" step="0.1" value="2.0"></label>

          <button id="addPuckBtn">Lägg till puck</button>
        </div>
        <div class="hint">Lägger till puck med position, radie, massa, stöttal, och begynnelsehastighet.</div>

        <h3 style="margin-top:12px;">Puckar</h3>
        <div id="puckList" class="puck-list"></div>
      </div>
    </div>

    <div class="right">
      <div class="topbar">
        <h2 style="margin:0;">Simulation</h2>
        <div class="hint" id="simHint">Lägg till puckar och tryck på Simulera!.</div>
      </div>

      <div id="simArea">
        <div class="hint">Ingen animation ännu.</div>
      </div>
    </div>
  </div>

  <!-- Pyodide -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.js"></script>

  <script>
    const statusEl = document.getElementById("status");
    const simulateBtn = document.getElementById("simulateBtn");
    const addPuckBtn = document.getElementById("addPuckBtn");
    const puckListEl = document.getElementById("puckList");
    const simHintEl = document.getElementById("simHint");
    const simAreaEl = document.getElementById("simArea");

    let pyodide = null;
    let pucks = []; // JS list of puck definitions

    function isFiniteNumber(x){ return Number.isFinite(x); }
    function readNum(id){
      const v = Number(document.getElementById(id).value);
      return isFiniteNumber(v) ? v : null;
    }

    function renderPuckList(){
      puckListEl.innerHTML = "";
      if (pucks.length === 0){
        puckListEl.innerHTML = `<div class="hint">Inga puckar än.</div>`;
        return;
      }
      pucks.forEach((p, idx) => {
        const div = document.createElement("div");
        div.className = "puck-item";
        div.innerHTML = `
          <code>
            #${idx+1} pos=(${p.x.toFixed(2)}, ${p.y.toFixed(2)})
            r=${p.radius.toFixed(2)} m=${p.mass.toFixed(2)} cor=${p.cor.toFixed(2)}
            v=(${p.vx.toFixed(2)}, ${p.vy.toFixed(2)})
          </code>
          <button data-remove="${idx}">Ta bort</button>
        `;
        div.querySelector("button").addEventListener("click", () => {
          pucks.splice(idx, 1);
          renderPuckList();
        });
        puckListEl.appendChild(div);
      });
    }

    addPuckBtn.addEventListener("click", () => {
      const x = readNum("px"), y = readNum("py"), radius = readNum("pr"),
            mass = readNum("pm"), cor = readNum("pcor"),
            vx = readNum("pvx"), vy = readNum("pvy");

      const vals = [x,y,radius,mass,cor,vx,vy];
      if (vals.some(v => v === null)){
        statusEl.textContent = "Fyll i alla puck-fält med giltiga tal.";
        return;
      }
      if (radius <= 0 || mass <= 0){
        statusEl.textContent = "Radie och massa måste vara > 0.";
        return;
      }
      if (cor < 0 || cor > 1){
        statusEl.textContent = "e är i intervallet [0, 1].";
        return;
      }

      pucks.push({x,y,radius,mass,cor,vx,vy});
      renderPuckList();
      statusEl.textContent = "Puck tillagd.";
    });

    async function initPyodideAndPackages(){
      statusEl.textContent = "Laddar Python runtime…";
      pyodide = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.29.0/full/" });

      statusEl.textContent = "Laddar numpy + matplotlib + pillow…";
      await pyodide.loadPackage(["numpy", "matplotlib", "pillow"]);

      pyodide.runPython(`
import math, base64
from io import BytesIO
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from matplotlib.animation import FuncAnimation, PillowWriter

class Puck:
    def __init__(self, pos, radius, mass, cor):
        self.pos = pos
        self.radius = radius
        self.mass = mass
        self.cor = cor
        self.velocity = (0.0, 0.0)

    def set_position(self, pos):
        self.pos = pos

    def set_velocity(self, vx, vy):
        self.velocity = (float(vx), float(vy))

    def get_velocity(self):
        return self.velocity

    def get_pos(self):
        return self.pos

    def get_radius(self):
        return self.radius

    def get_mass(self):
        return self.mass

    def get_cor(self):
        return self.cor

class Room:
    def __init__(self, friction):
        self.friction = float(friction)
        self.pucks = []

    def add(self, puck):
        self.pucks.append(puck)

    def update_step(self, dt):
        length = len(self.pucks)

        # collisions
        for i in range(length):
            for j in range(i + 1, length):
                p1, p2 = self.pucks[i], self.pucks[j]
                if self.collision(p1, p2):
                    v1_after, v2_after = self.collision_velocities(p1, p2)
                    p1.set_velocity(*v1_after)
                    p2.set_velocity(*v2_after)

                    # separate overlap
                    n = self.collision_normal(p1, p2)
                    d = self.distance(p1, p2)
                    collision_radius = p1.get_radius() + p2.get_radius()
                    dist = math.sqrt(self._prod(d, d))
                    extra_margin = (collision_radius - dist) if dist > 0 else collision_radius
                    p1.set_position(self._sum(p1.get_pos(), self._mult_scalar(extra_margin, n)))
                    p2.set_position(self._sum(p2.get_pos(), self._mult_scalar(-extra_margin, n)))

        # integrate
        for puck in self.pucks:
            v = puck.get_velocity()
            pos = puck.get_pos()

            new_pos = self._sum(pos, self._mult_scalar(dt, v))
            a = self._deceleration(puck)
            new_v = self._diff(v, self._mult_scalar(dt, a))

            puck.set_position(new_pos)
            puck.set_velocity(*new_v)

    def collision_velocities(self, p1, p2):
        m1, m2 = p1.get_mass(), p2.get_mass()
        e = max(p1.get_cor(), p2.get_cor())
        n = self.collision_normal(p1, p2)
        v1, v2 = p1.get_velocity(), p2.get_velocity()
        return self._collision_equations(m1, m2, e, n, v1, v2)

    def _collision_equations(self, m1, m2, e, n, v1, v2):
        rel = self._diff(v1, v2)
        k = self._prod(rel, n)
        v1_after = self._diff(v1, self._mult_scalar((1 + e) * m2 / (m1 + m2) * k, n))
        v2_after = self._sum(v2, self._mult_scalar((1 + e) * m1 / (m1 + m2) * k, n))
        return v1_after, v2_after

    def collision_normal(self, p1, p2):
        d = self.distance(p1, p2)
        norm = math.sqrt(self._prod(d, d))
        return self._div(d, norm)

    def distance(self, p1, p2):
        return self._diff(p1.get_pos(), p2.get_pos())

    def collision(self, p1, p2):
        d = self.distance(p1, p2)
        r = p1.get_radius() + p2.get_radius()
        return self._prod(d, d) < r * r

    def _deceleration(self, puck):
        g = 9.82
        vx, vy = puck.get_velocity()
        speed = math.sqrt(vx*vx + vy*vy)
        if speed == 0.0:
            return (0.0, 0.0)
        dir_v = (vx / speed, vy / speed)
        return self._mult_scalar(self.friction * g, dir_v)

    def _prod(self, a, b):
        return a[0]*b[0] + a[1]*b[1]
    def _diff(self, a, b):
        return (a[0]-b[0], a[1]-b[1])
    def _sum(self, a, b):
        return (a[0]+b[0], a[1]+b[1])
    def _mult_scalar(self, s, v):
        return (s*v[0], s*v[1])
    def _div(self, v, s):
        if s == 0.0:
            return (0.0, 0.0)
        return (v[0]/s, v[1]/s)

DT = 0.002
FPS = 60

def simulate_to_gif_base64(pucks_data, friction, T):
    dt = DT
    fps = FPS
    T = float(T)
    friction = float(friction)

    room = Room(friction)
    pucks = []

    for p in pucks_data:
        puck = Puck(
            (float(p["x"]), float(p["y"])),
            float(p["radius"]),
            float(p["mass"]),
            float(p["cor"]),
        )
        puck.set_velocity(float(p["vx"]), float(p["vy"]))
        room.add(puck)
        pucks.append(puck)

    steps = int(max(1, math.ceil(T / dt)))
    target_frames = max(1, int(T * fps))
    k = max(1, steps // target_frames)

    frames = []
    radii = [p.get_radius() for p in pucks]

    for s in range(steps + 1):
        if s % k == 0:
            frames.append([p.get_pos() for p in pucks])
        room.update_step(dt)

    # bounds from all frames + radii
    xs, ys = [], []
    for fr in frames:
        for (x,y) in fr:
            xs.append(x); ys.append(y)
    if xs:
        xmin, xmax = min(xs), max(xs)
        ymin, ymax = min(ys), max(ys)
    else:
        xmin=xmax=ymin=ymax=0.0

    rmax = max(radii) if radii else 0.2
    span = max(xmax-xmin, ymax-ymin, 1.0)
    pad = 0.15 * span + rmax
    xlim = (xmin - pad, xmax + pad)
    ylim = (ymin - pad, ymax + pad)

    # Build animation in Matplotlib
    fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
    ax.set_xlim(*xlim)
    ax.set_ylim(*ylim)
    ax.set_aspect("equal", adjustable="box")
    ax.grid(True, alpha=0.25)

    circles = []
    for i, r in enumerate(radii):
        c = Circle((0,0), r, fill=False, linewidth=2)
        ax.add_patch(c)
        circles.append(c)

    title = ax.set_title("t = 0.00 s")

    def init():
        for c in circles:
            c.center = (0,0)
        title.set_text("t = 0.00 s")
        return circles + [title]

    def update(fi):
        fr = frames[fi]
        for i, c in enumerate(circles):
            x,y = fr[i]
            c.center = (x,y)
        title.set_text(f"t = {fi / fps:.2f} s")
        return circles + [title]

    anim = FuncAnimation(fig, update, init_func=init, frames=len(frames), interval=1000/fps, blit=True)

    buf = BytesIO()
    anim.save(buf, writer=PillowWriter(fps=fps), format="gif")
    plt.close(fig)
    buf.seek(0)
    return base64.b64encode(buf.read()).decode("utf-8")
      `);

      statusEl.textContent = "Redo.";
      simulateBtn.disabled = false;
    }

    simulateBtn.addEventListener("click", () => {
      doSimulate().catch(err => {
        statusEl.textContent = "Fel.";
        simHintEl.textContent = err?.message || String(err);
      });
    });

    async function doSimulate(){
      if (!pyodide) return;
      if (pucks.length === 0){
        statusEl.textContent = "Lägg till åtminstone en puck.";
        return;
      }

      const friction = readNum("friction");
      const T = readNum("T");

      if ([friction, T].some(v => v === null)){
        statusEl.textContent = "Fyll i friction/T med giltiga tal.";
        return;
      }
      if (friction < 0){
        statusEl.textContent = "Friktionen måste vara >= 0.";
        return;
      }
      if (T <= 0){
        statusEl.textContent = "T måste vara > 0.";
        return;
      }

      simulateBtn.disabled = true;
      statusEl.textContent = "Simulerar + renderar GIF…";
      simHintEl.textContent = "Allt sker i Python (Matplotlib).";

      // Pass data to Python
      pyodide.globals.set("pucks_js", pyodide.toPy(pucks));
      pyodide.globals.set("friction_js", friction);
      pyodide.globals.set("T_js", T);

      const b64gif = pyodide.runPython("simulate_to_gif_base64(pucks_js, friction_js, T_js)");

      simAreaEl.innerHTML = `<img alt="Simulation GIF" src="data:image/gif;base64,${b64gif}">`;

      statusEl.textContent = "Klar.";
      simHintEl.textContent = "GIF genererad av Matplotlib.";
      simulateBtn.disabled = false;
    }

    // init
    renderPuckList();
    initPyodideAndPackages().catch(err => {
      statusEl.textContent = "Lyckades inte ladda Python.";
      simHintEl.textContent = err?.message || String(err);
    });
  </script>
</body>
</html>
