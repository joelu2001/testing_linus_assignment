<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2D kollision i planet</title>
  <style>
    body {margin:0;font-family:system-ui,Arial,sans-serif;background:#121212;color:#e0e0e0;}
    .wrap {display:flex;height:100vh;}
    .left {width:40%;padding:12px;border-right:1px solid #333;box-sizing:border-box;overflow:auto;background:#1e1e1e;}
    .right {width:60%;padding:12px;box-sizing:border-box;overflow:auto;background:#1e1e1e;display:flex;flex-direction:column;gap:10px;}
    .author-note {text-align: center;font-size: 0.8rem;opacity: 0.6;margin-bottom: 6px;}

    h2,h3{margin:10px 0;}
    .row {display:flex;gap:8px;flex-wrap:wrap;align-items:end;margin:10px 0;}
    label {font-size:0.85rem;opacity:0.95;display:flex;flex-direction:column;gap:4px;}
    input {width:140px;box-sizing:border-box;background:#2a2a2a;color:#e0e0e0;border:1px solid #444;padding:8px;border-radius:6px;}
    input.small{width:110px;}
    button {padding:10px 14px;background:#333;color:#e0e0e0;border:1px solid #555;cursor:pointer;border-radius:8px;}
    button:hover {background:#444;}
    button:disabled{opacity:0.6;cursor:not-allowed;}

    #status {font-size:0.9rem;opacity:0.9;}
    .card {border:1px solid #333;background:#181818;border-radius:10px;padding:10px;margin:10px 0;}
    .puck-list {display:flex;flex-direction:column;gap:8px;}
    .puck-item {display:flex;justify-content:space-between;gap:10px;align-items:center;border:1px solid #333;background:#171717;border-radius:10px;padding:8px;}
    .puck-item code {font-size:0.85rem;opacity:0.95;}
    .hint {font-size:0.9rem;opacity:0.9;}

    #simArea {flex:1;border:1px solid #333;background:#111;border-radius:12px;display:grid;place-items:center;overflow:hidden;padding:10px;}
    #simArea img {max-width:100%;height:auto;display:block;border-radius:10px;}
    .topbar {display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="left">
      <div class="author-note">Utvecklat av Joel Utsi & Linus Andersson</div>
      <h2>Puckdata</h2>

      <div class="row">
        <button id="simulateBtn" disabled>Simulera!</button>
        <span id="status">Laddar Python…</span>
      </div>

      <div class="card">
        <h3>Rum</h3>
        <div class="row">
          <label>
            Friktion (μ)
            <input id="friction" type="number" step="0.01" value="0.10" />
          </label>

          <label>
            Simuleringstid (s)
            <input id="T" type="number" step="0.1" value="5.0" />
          </label>
        </div>
      </div>

      <div class="card">
        <h3>Puck</h3>
        <div class="row">
          <label>pos x <input id="px" class="small" type="number" step="0.1" value="-1.0"></label>
          <label>pos y <input id="py" class="small" type="number" step="0.1" value="-1.0"></label>
          <label>radie <input id="pr" class="small" type="number" step="0.01" value="0.15"></label>
          <label>massa <input id="pm" class="small" type="number" step="0.01" value="1.0"></label>
          <label>e <input id="pcor" class="small" type="number" step="0.01" value="0.30"></label>
          <label>vx <input id="pvx" class="small" type="number" step="0.1" value="2.0"></label>
          <label>vy <input id="pvy" class="small" type="number" step="0.1" value="2.0"></label>

          <button id="addPuckBtn">Lägg till puck</button>
        </div>
        <div class="hint">Lägger till puck med position, radie, massa, stöttal, och begynnelsehastighet.</div>

        <h3 style="margin-top:12px;">Puckar</h3>
        <div id="puckList" class="puck-list"></div>
      </div>
    </div>

    <div class="right">
      <div class="topbar">
        <h2 style="margin:0;">Simulation</h2>
        <div class="hint" id="simHint">Lägg till puckar och tryck på Simulera!</div>
      </div>

      <div id="simArea">
        <div class="hint">Inget att visa än.</div>
      </div>
    </div>
  </div>

  <!-- Pyodide -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.js"></script>

  <script>
    const statusEl = document.getElementById("status");
    const simulateBtn = document.getElementById("simulateBtn");
    const addPuckBtn = document.getElementById("addPuckBtn");
    const puckListEl = document.getElementById("puckList");
    const simHintEl = document.getElementById("simHint");
    const simAreaEl = document.getElementById("simArea");

    let pyodide = null;
    let pucks = [];

    function isFiniteNumber(x){ return Number.isFinite(x); }
    function readNum(id){
      const v = Number(document.getElementById(id).value);
      return isFiniteNumber(v) ? v : null;
    }

    function renderPuckList(){
      puckListEl.innerHTML = "";
      if (pucks.length === 0){
        puckListEl.innerHTML = `<div class="hint">Inga puckar än.</div>`;
        return;
      }
      pucks.forEach((p, idx) => {
        const div = document.createElement("div");
        div.className = "puck-item";
        div.innerHTML = `
          <code>
            #${idx+1} pos=(${p.x.toFixed(2)}, ${p.y.toFixed(2)})
            r=${p.radius.toFixed(2)} m=${p.mass.toFixed(2)} cor=${p.cor.toFixed(2)}
            v=(${p.vx.toFixed(2)}, ${p.vy.toFixed(2)})
          </code>
          <button data-remove="${idx}">Ta bort</button>
        `;
        div.querySelector("button").addEventListener("click", () => {
          pucks.splice(idx, 1);
          renderPuckList();
        });
        puckListEl.appendChild(div);
      });
    }

    addPuckBtn.addEventListener("click", () => {
      const x = readNum("px"), y = readNum("py"), radius = readNum("pr"),
            mass = readNum("pm"), cor = readNum("pcor"),
            vx = readNum("pvx"), vy = readNum("pvy");

      const vals = [x,y,radius,mass,cor,vx,vy];
      if (vals.some(v => v === null)){
        statusEl.textContent = "Fyll i alla puck-fält med giltiga tal.";
        return;
      }
      if (radius <= 0 || mass <= 0){
        statusEl.textContent = "Radie och massa måste vara > 0.";
        return;
      }
      if (cor < 0 || cor > 1){
        statusEl.textContent = "e är i intervallet [0, 1].";
        return;
      }

      pucks.push({x,y,radius,mass,cor,vx,vy});
      renderPuckList();
      statusEl.textContent = "Puck tillagd.";
    });

    async function initPyodideAndPackages(){
      statusEl.textContent = "Laddar Python runtime…";
      pyodide = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.29.0/full/" });

      statusEl.textContent = "Laddar numpy + matplotlib + pillow…";
      await pyodide.loadPackage(["numpy", "matplotlib", "pillow"]);

      pyodide.runPython(`
import math, base64, os
import numpy as np
from io import BytesIO
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from matplotlib.animation import FuncAnimation, PillowWriter
from PIL import Image

class Puck:
    def __init__(self, pos, radius, mass, cor):
        self.pos = pos
        self.radius = radius
        self.mass = mass
        self.cor = cor
        self.velocity = (0.0, 0.0)

    def set_position(self, pos):
        self.pos = pos

    def set_velocity(self, vx, vy):
        self.velocity = (float(vx), float(vy))

    def get_velocity(self):
        return self.velocity

    def get_pos(self):
        return self.pos

    def get_radius(self):
        return self.radius

    def get_mass(self):
        return self.mass

    def get_cor(self):
        return self.cor

class Room:
    def __init__(self, friction):
        self.friction = float(friction)
        self.pucks = []

    def add(self, puck):
        self.pucks.append(puck)

    def update_step(self, dt):
        length = len(self.pucks)

        # collisions
        for i in range(length):
            for j in range(i + 1, length):
                p1, p2 = self.pucks[i], self.pucks[j]
                if self.collision(p1, p2):
                    v1_after, v2_after = self.collision_velocities(p1, p2)
                    p1.set_velocity(*v1_after)
                    p2.set_velocity(*v2_after)

                    # separate overlap
                    n = self.collision_normal(p1, p2)
                    d = self.distance(p1, p2)
                    collision_radius = p1.get_radius() + p2.get_radius()
                    dist = math.sqrt(self._prod(d, d))
                    extra_margin = (collision_radius - dist) if dist > 0 else collision_radius
                    p1.set_position(self._sum(p1.get_pos(), self._mult_scalar(extra_margin, n)))
                    p2.set_position(self._sum(p2.get_pos(), self._mult_scalar(-extra_margin, n)))

        # integrate
        for puck in self.pucks:
            vx, vy = puck.get_velocity()
            x, y = puck.get_pos()

            new_pos = (x + dt * vx, y + dt * vy)

            ax, ay = self._deceleration(puck)
            new_v = (vx - dt * ax, vy - dt * ay)

            puck.set_position(new_pos)
            puck.set_velocity(*new_v)

    def collision_velocities(self, p1, p2):
        m1, m2 = p1.get_mass(), p2.get_mass()
        e = max(p1.get_cor(), p2.get_cor())
        n = self.collision_normal(p1, p2)
        v1, v2 = p1.get_velocity(), p2.get_velocity()
        return self._collision_equations(m1, m2, e, n, v1, v2)

    def _collision_equations(self, m1, m2, e, n, v1, v2):
        rel = self._diff(v1, v2)
        k = self._prod(rel, n)
        v1_after = self._diff(v1, self._mult_scalar((1 + e) * m2 / (m1 + m2) * k, n))
        v2_after = self._sum(v2, self._mult_scalar((1 + e) * m1 / (m1 + m2) * k, n))
        return v1_after, v2_after

    def collision_normal(self, p1, p2):
        d = self.distance(p1, p2)
        norm = math.sqrt(self._prod(d, d))
        return self._div(d, norm)

    def distance(self, p1, p2):
        return self._diff(p1.get_pos(), p2.get_pos())

    def collision(self, p1, p2):
        d = self.distance(p1, p2)
        r = p1.get_radius() + p2.get_radius()
        return self._prod(d, d) < r * r

    def _deceleration(self, puck):
        g = 9.82
        vx, vy = puck.get_velocity()
        speed = math.sqrt(vx*vx + vy*vy)
        if speed == 0.0:
            return (0.0, 0.0)
        dir_v = (vx / speed, vy / speed)
        return self._mult_scalar(self.friction * g, dir_v)

    def _prod(self, a, b):
        return a[0]*b[0] + a[1]*b[1]
    def _diff(self, a, b):
        return (a[0]-b[0], a[1]-b[1])
    def _sum(self, a, b):
        return (a[0]+b[0], a[1]+b[1])
    def _mult_scalar(self, s, v):
        return (s*v[0], s*v[1])
    def _div(self, v, s):
        if s == 0.0:
            return (0.0, 0.0)
        return (v[0]/s, v[1]/s)

DT = 0.002
FPS = 24

def simulate_to_media_base64(pucks_data, friction, T):
    dt = DT
    fps = FPS
    T = float(T)
    friction = float(friction)

    room = Room(friction)
    pucks = []
    for p in pucks_data:
        puck = Puck(
            (float(p["x"]), float(p["y"])),
            float(p["radius"]),
            float(p["mass"]),
            float(p["cor"]),
        )
        puck.set_velocity(float(p["vx"]), float(p["vy"]))
        room.add(puck)
        pucks.append(puck)

    steps = int(max(1, math.ceil(T / dt)))

    target_frames = max(1, int(T * fps))
    k = max(1, steps // target_frames)

    frames_pos = []
    frames_vel = []
    for s in range(steps + 1):
        if s % k == 0:
            frames_pos.append([p.get_pos() for p in pucks])
            frames_vel.append([p.get_velocity() for p in pucks])
        room.update_step(dt)

    radii = [p.get_radius() for p in pucks]

    xmin = ymin = float("inf")
    xmax = ymax = float("-inf")
    for fr in frames_pos:
        for i, (x, y) in enumerate(fr):
            r = radii[i]
            xmin = min(xmin, x - r); xmax = max(xmax, x + r)
            ymin = min(ymin, y - r); ymax = max(ymax, y + r)
    span = max(xmax - xmin, ymax - ymin, 1.0)
    pad = 0.12 * span
    xmin -= pad; xmax += pad; ymin -= pad; ymax += pad

    fig, ax = plt.subplots(figsize=(6.4, 4.0), dpi=140)
    bg = "#0f1115"
    fig.patch.set_facecolor(bg)
    ax.set_facecolor(bg)

    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)
    ax.set_aspect("equal", adjustable="box")

    ax.set_xticks([]); ax.set_yticks([])
    for sp in ax.spines.values():
        sp.set_visible(False)

    circles = []
    for i in range(len(pucks)):
        c = Circle((0, 0), radii[i], fill=False, linewidth=2.2, edgecolor="#e6e6e6", alpha=0.95)
        ax.add_patch(c)
        circles.append(c)

    label_offset = 0.02 * span  # tweak if you want more/less gap

    texts = []
    for i in range(len(pucks)):
        t = ax.text(
            0, 0, f"P{i+1}",
            ha="center", va="bottom",
            fontsize=9,
            color="#eaeaea",
            family="sans-serif",
            weight="bold",
        )
        texts.append(t)

    hud = ax.text(
        0.02, 0.02, "",
        transform=ax.transAxes,
        va="bottom", ha="left",
        fontsize=7,
        color="#eaeaea",
        family="monospace",
        bbox=dict(
            boxstyle="round,pad=0.25",
            facecolor=(0,0,0,0.22),
            edgecolor=(1,1,1,0.10)
        )
    )

    def init():
        if len(frames_pos) > 0:
            for i, (x, y) in enumerate(frames_pos[0]):
                circles[i].center = (x, y)
                texts[i].set_position((x, y + radii[i] + label_offset))
        hud.set_text("")
        return circles + texts + [hud]

    def update(frame_idx):
        pos = frames_pos[frame_idx]
        vel = frames_vel[frame_idx]

        for i, (x, y) in enumerate(pos):
            circles[i].center = (x, y)
            texts[i].set_position((x, y + radii[i] + label_offset))

        lines = []
        for i, ((x, y), (vx, vy)) in enumerate(zip(pos, vel), start=1):
            lines.append(f"P{i}: x={x:+.2f} y={y:+.2f}  vx={vx:+.2f} vy={vy:+.2f}")

        hud.set_text("\\n".join(lines))
        return circles + texts + [hud]

    anim = FuncAnimation(
        fig,
        update,
        init_func=init,
        frames=len(frames_pos),
        interval=1000 / fps,
        blit=True,
    )

    out_path = "/tmp/sim.gif"
    writer = PillowWriter(fps=fps)
    anim.save(out_path, writer=writer)
    plt.close(fig)

    with open(out_path, "rb") as f:
        gif_bytes = f.read()

    try:
        os.remove(out_path)
    except Exception:
        pass

    duration_ms = int(len(frames_pos) * (1000 / fps))

    return {
        "gif_b64": base64.b64encode(gif_bytes).decode("utf-8"),
        "last_png_b64": "",
        "duration_ms": duration_ms
    }
      `);

      statusEl.textContent = "Redo.";
      simulateBtn.disabled = false;
    }

    simulateBtn.addEventListener("click", () => {
      doSimulate().catch(err => {
        statusEl.textContent = "Fel.";
        simHintEl.textContent = err?.message || String(err);
      });
    });

    let lastFreezeTimer = null;
    let simRunId = 0;

    async function doSimulate(){
      if (!pyodide) return;
      if (pucks.length === 0){
        statusEl.textContent = "Lägg till åtminstone en puck.";
        return;
      }

      const friction = readNum("friction");
      const T = readNum("T");

      if ([friction, T].some(v => v === null)){
        statusEl.textContent = "Fyll i friction/T med giltiga tal.";
        return;
      }
      if (friction < 0){
        statusEl.textContent = "Friktionen måste vara >= 0.";
        return;
      }
      if (T <= 0){
        statusEl.textContent = "T måste vara > 0.";
        return;
      }

      simRunId += 1;
      const runId = simRunId;

      if (lastFreezeTimer) {
        clearTimeout(lastFreezeTimer);
        lastFreezeTimer = null;
      }

      simulateBtn.disabled = true;
      statusEl.textContent = "Simulerar + renderar GIF...";
      simHintEl.textContent = "Simulerar i Matplotlib...";

      simAreaEl.innerHTML = `<div class="hint">Renderar…</div>`;

      pyodide.globals.set("pucks_js", pyodide.toPy(pucks));
      pyodide.globals.set("friction_js", friction);
      pyodide.globals.set("T_js", T);

      const pyRes = await pyodide.runPythonAsync(
        "simulate_to_media_base64(pucks_js, friction_js, T_js)"
      );

      if (runId !== simRunId) {
        try { pyRes.destroy(); } catch(e) {}
        return;
      }

      const res = pyRes.toJs({ dict_converter: Object.fromEntries });
      try { pyRes.destroy(); } catch(e) {}

      const gifB64 = res.gif_b64;

      simAreaEl.innerHTML = `<img id="simImg" alt="Simulation GIF" src="data:image/gif;base64,${gifB64}">`;

      statusEl.textContent = "Klar.";
      simHintEl.textContent = "Tryck Simulera! för ny simulering.";
      simulateBtn.disabled = false;
    }

    renderPuckList();
    initPyodideAndPackages().catch(err => {
      statusEl.textContent = "Lyckades inte ladda Python.";
      simHintEl.textContent = err?.message || String(err);
    });
  </script>
</body>
</html>
