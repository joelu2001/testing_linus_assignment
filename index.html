<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2D kollision i planet</title>
  <style>
    body {margin:0;font-family:system-ui,Arial,sans-serif;background:#121212;color:#e0e0e0;}
    .wrap {display:flex;height:100vh;}
    .left {width:40%;padding:12px;border-right:1px solid #333;box-sizing:border-box;overflow:auto;background:#1e1e1e;}
    .right {width:60%;padding:12px;box-sizing:border-box;overflow:auto;background:#1e1e1e;display:flex;flex-direction:column;gap:10px;}
    .author-note {text-align: center;font-size: 0.8rem;opacity: 0.6;margin-bottom: 6px;}

    h2,h3{margin:10px 0;}
    .row {display:flex;gap:8px;flex-wrap:wrap;align-items:end;margin:10px 0;}
    label {font-size:0.85rem;opacity:0.95;display:flex;flex-direction:column;gap:4px;}
    input {width:140px;box-sizing:border-box;background:#2a2a2a;color:#e0e0e0;border:1px solid #444;padding:8px;border-radius:6px;}
    input.small{width:110px;}
    button {padding:10px 14px;background:#333;color:#e0e0e0;border:1px solid #555;cursor:pointer;border-radius:8px;}
    button:hover {background:#444;}
    button:disabled{opacity:0.6;cursor:not-allowed;}

    #status {font-size:0.9rem;opacity:0.9;}
    .card {border:1px solid #333;background:#181818;border-radius:10px;padding:10px;margin:10px 0;}
    .puck-list {display:flex;flex-direction:column;gap:8px;}
    .puck-item {display:flex;justify-content:space-between;gap:10px;align-items:center;border:1px solid #333;background:#171717;border-radius:10px;padding:8px;}
    .puck-item code {font-size:0.85rem;opacity:0.95;}
    .hint {font-size:0.9rem;opacity:0.9;}

    #simArea {flex:1;border:1px solid #333;background:#111;border-radius:12px;display:grid;place-items:center;overflow:hidden;padding:10px;}
    #simArea img {max-width:100%;height:auto;display:block;border-radius:10px;}
    .topbar {display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="left">
      <div class="author-note">Utvecklat av Joel Utsi & Linus Andersson</div>
      <h2>Puckdata</h2>

      <div class="row">
        <button id="simulateBtn" disabled>Simulera!</button>
        <span id="status">Laddar Python…</span>
      </div>

      <div class="card">
        <h3>Rum</h3>
        <div class="row">
          <label>
            Friktion (μ)
            <input id="friction" type="number" step="0.01" value="0.10" />
          </label>

          <label>
            Simuleringstid (s)
            <input id="T" type="number" step="0.1" value="5.0" />
          </label>
        </div>
      </div>

      <div class="card">
        <h3>Puck</h3>
        <div class="row">
          <label>pos x <input id="px" class="small" type="number" step="0.1" value="-1.0"></label>
          <label>pos y <input id="py" class="small" type="number" step="0.1" value="-1.0"></label>
          <label>radie <input id="pr" class="small" type="number" step="0.01" value="0.15"></label>
          <label>massa <input id="pm" class="small" type="number" step="0.01" value="1.0"></label>
          <label>e <input id="pcor" class="small" type="number" step="0.01" value="0.30"></label>
          <label>vx <input id="pvx" class="small" type="number" step="0.1" value="2.0"></label>
          <label>vy <input id="pvy" class="small" type="number" step="0.1" value="2.0"></label>

          <button id="addPuckBtn">Lägg till puck</button>
        </div>
        <div class="hint">Lägger till puck med position, radie, massa, stöttal, och begynnelsehastighet.</div>

        <h3 style="margin-top:12px;">Puckar</h3>
        <div id="puckList" class="puck-list"></div>
      </div>
    </div>

    <div class="right">
      <div class="topbar">
        <h2 style="margin:0;">Simulation</h2>
        <div class="hint" id="simHint">Lägg till puckar och tryck på Simulera!.</div>
      </div>

      <div id="simArea">
        <div class="hint">Ingen animation ännu.</div>
      </div>
    </div>
  </div>

  <!-- Pyodide -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.js"></script>

  <script>
    const statusEl = document.getElementById("status");
    const simulateBtn = document.getElementById("simulateBtn");
    const addPuckBtn = document.getElementById("addPuckBtn");
    const puckListEl = document.getElementById("puckList");
    const simHintEl = document.getElementById("simHint");
    const simAreaEl = document.getElementById("simArea");

    let pyodide = null;
    let pucks = []; // JS list of puck definitions

    function isFiniteNumber(x){ return Number.isFinite(x); }
    function readNum(id){
      const v = Number(document.getElementById(id).value);
      return isFiniteNumber(v) ? v : null;
    }

    function renderPuckList(){
      puckListEl.innerHTML = "";
      if (pucks.length === 0){
        puckListEl.innerHTML = `<div class="hint">Inga puckar än.</div>`;
        return;
      }
      pucks.forEach((p, idx) => {
        const div = document.createElement("div");
        div.className = "puck-item";
        div.innerHTML = `
          <code>
            #${idx+1} pos=(${p.x.toFixed(2)}, ${p.y.toFixed(2)})
            r=${p.radius.toFixed(2)} m=${p.mass.toFixed(2)} cor=${p.cor.toFixed(2)}
            v=(${p.vx.toFixed(2)}, ${p.vy.toFixed(2)})
          </code>
          <button data-remove="${idx}">Ta bort</button>
        `;
        div.querySelector("button").addEventListener("click", () => {
          pucks.splice(idx, 1);
          renderPuckList();
        });
        puckListEl.appendChild(div);
      });
    }

    addPuckBtn.addEventListener("click", () => {
      const x = readNum("px"), y = readNum("py"), radius = readNum("pr"),
            mass = readNum("pm"), cor = readNum("pcor"),
            vx = readNum("pvx"), vy = readNum("pvy");

      const vals = [x,y,radius,mass,cor,vx,vy];
      if (vals.some(v => v === null)){
        statusEl.textContent = "Fyll i alla puck-fält med giltiga tal.";
        return;
      }
      if (radius <= 0 || mass <= 0){
        statusEl.textContent = "Radie och massa måste vara > 0.";
        return;
      }
      if (cor < 0 || cor > 1){
        statusEl.textContent = "e är i intervallet [0, 1].";
        return;
      }

      pucks.push({x,y,radius,mass,cor,vx,vy});
      renderPuckList();
      statusEl.textContent = "Puck tillagd.";
    });

    async function initPyodideAndPackages(){
      statusEl.textContent = "Laddar Python runtime…";
      pyodide = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.29.0/full/" });

      statusEl.textContent = "Laddar numpy + matplotlib + pillow…";
      await pyodide.loadPackage(["numpy", "matplotlib", "pillow"]);

      pyodide.runPython(`
import math, base64, os
from io import BytesIO

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from matplotlib.animation import FuncAnimation, PillowWriter

# ---------------- Physics ----------------

class Puck:
    def __init__(self, pos, radius, mass, cor):
        self.pos = (float(pos[0]), float(pos[1]))
        self.radius = float(radius)
        self.mass = float(mass)
        self.cor = float(cor)
        self.velocity = (0.0, 0.0)

    def set_position(self, pos):
        self.pos = (float(pos[0]), float(pos[1]))

    def set_velocity(self, vx, vy):
        self.velocity = (float(vx), float(vy))

    def get_velocity(self):
        return self.velocity

    def get_pos(self):
        return self.pos

    def get_radius(self):
        return self.radius

    def get_mass(self):
        return self.mass

    def get_cor(self):
        return self.cor


class Room:
    def __init__(self, friction):
        self.friction = float(friction)
        self.pucks = []

    def add(self, puck):
        self.pucks.append(puck)

    def update_step(self, dt):
        length = len(self.pucks)

        # collisions
        for i in range(length):
            for j in range(i + 1, length):
                p1, p2 = self.pucks[i], self.pucks[j]
                if self.collision(p1, p2):
                    v1_after, v2_after = self.collision_velocities(p1, p2)
                    p1.set_velocity(*v1_after)
                    p2.set_velocity(*v2_after)

                    # separate overlap (simple)
                    n = self.collision_normal(p1, p2)
                    d = self.distance(p1, p2)
                    collision_radius = p1.get_radius() + p2.get_radius()
                    dist = math.sqrt(self._prod(d, d))
                    extra_margin = (collision_radius - dist) if dist > 0 else collision_radius
                    p1.set_position(self._sum(p1.get_pos(), self._mult_scalar(+0.5 * extra_margin, n)))
                    p2.set_position(self._sum(p2.get_pos(), self._mult_scalar(-0.5 * extra_margin, n)))

        # integrate
        for puck in self.pucks:
            vx, vy = puck.get_velocity()
            x, y = puck.get_pos()

            # position
            x2, y2 = x + dt * vx, y + dt * vy

            # friction decel
            ax, ay = self._deceleration(puck)
            vx2, vy2 = vx - dt * ax, vy - dt * ay

            # stop tiny drift
            if vx2 * vx2 + vy2 * vy2 < 1e-10:
                vx2, vy2 = 0.0, 0.0

            puck.set_position((x2, y2))
            puck.set_velocity(vx2, vy2)

    def collision_velocities(self, p1, p2):
        m1, m2 = p1.get_mass(), p2.get_mass()
        e = max(p1.get_cor(), p2.get_cor())
        n = self.collision_normal(p1, p2)
        v1, v2 = p1.get_velocity(), p2.get_velocity()
        return self._collision_equations(m1, m2, e, n, v1, v2)

    def _collision_equations(self, m1, m2, e, n, v1, v2):
        rel = self._diff(v1, v2)
        k = self._prod(rel, n)
        v1_after = self._diff(v1, self._mult_scalar((1 + e) * m2 / (m1 + m2) * k, n))
        v2_after = self._sum(v2, self._mult_scalar((1 + e) * m1 / (m1 + m2) * k, n))
        return v1_after, v2_after

    def collision_normal(self, p1, p2):
        d = self.distance(p1, p2)
        norm = math.sqrt(self._prod(d, d))
        return self._div(d, norm)

    def distance(self, p1, p2):
        return self._diff(p1.get_pos(), p2.get_pos())

    def collision(self, p1, p2):
        d = self.distance(p1, p2)
        r = p1.get_radius() + p2.get_radius()
        return self._prod(d, d) < r * r

    def _deceleration(self, puck):
        g = 9.82
        vx, vy = puck.get_velocity()
        speed = math.sqrt(vx * vx + vy * vy)
        if speed == 0.0:
            return (0.0, 0.0)
        dir_v = (vx / speed, vy / speed)
        # magnitude = mu*g
        return self._mult_scalar(self.friction * g, dir_v)

    def _prod(self, a, b): return a[0] * b[0] + a[1] * b[1]
    def _diff(self, a, b): return (a[0] - b[0], a[1] - b[1])
    def _sum(self, a, b):  return (a[0] + b[0], a[1] + b[1])
    def _mult_scalar(self, s, v): return (s * v[0], s * v[1])
    def _div(self, v, s):
        if s == 0.0: return (0.0, 0.0)
        return (v[0] / s, v[1] / s)

# ---------------- Rendering ----------------

DT  = 0.002
FPS = 24

def simulate_to_gif_base64(pucks_data, friction, T):
    dt = DT
    fps = FPS
    T = float(T)
    friction = float(friction)

    room = Room(friction)
    pucks = []

    for p in pucks_data:
        puck = Puck(
            (float(p["x"]), float(p["y"])),
            float(p["radius"]),
            float(p["mass"]),
            float(p["cor"]),
        )
        puck.set_velocity(float(p["vx"]), float(p["vy"]))
        room.add(puck)
        pucks.append(puck)

    steps = int(max(1, math.ceil(T / dt)))

    # Record ~fps frames
    target_frames = max(1, int(T * fps))
    k = max(1, steps // target_frames)

    # Store BOTH position and velocity per puck per frame
    frames = []
    for s in range(steps + 1):
        if s % k == 0:
            frames.append([(pu.get_pos(), pu.get_velocity()) for pu in pucks])
        room.update_step(dt)

    radii = [pu.get_radius() for pu in pucks]

    # Compute bounds from positions only
    xmin = ymin = float("inf")
    xmax = ymax = float("-inf")
    for fr in frames:
        for i, (pos, vel) in enumerate(fr):
            x, y = pos
            r = radii[i]
            xmin = min(xmin, x - r); xmax = max(xmax, x + r)
            ymin = min(ymin, y - r); ymax = max(ymax, y + r)

    span = max(xmax - xmin, ymax - ymin, 1.0)
    pad = 0.12 * span
    xmin -= pad; xmax += pad; ymin -= pad; ymax += pad

    # --- "Modern" dark look ---
    fig, ax = plt.subplots(figsize=(7.0, 4.5), dpi=140)
    fig.patch.set_facecolor("#0f1115")
    ax.set_facecolor("#0f1115")

    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)
    ax.set_aspect("equal", adjustable="box")

    # Remove axes/border entirely
    ax.set_axis_off()

    # Puck circles
    circles = []
    for i in range(len(pucks)):
        c = Circle((0, 0), radii[i], fill=False, linewidth=2.5, edgecolor="#e0e0e0")
        ax.add_patch(c)
        circles.append(c)

    # HUD text INSIDE the plot (top-left)
    hud = ax.text(
        0.02, 0.98, "",
        transform=ax.transAxes,
        va="top", ha="left",
        fontsize=10,
        color="#e6e6e6",
        family="monospace",
        bbox=dict(boxstyle="round,pad=0.45", facecolor=(0,0,0,0.35), edgecolor=(1,1,1,0.10))
    )

    def init():
        # Start circles at first frame positions
        fr0 = frames[0]
        for i, (pos, vel) in enumerate(fr0):
            circles[i].center = pos
        hud.set_text("")
        return circles + [hud]

    def update(frame_idx):
        fr = frames[frame_idx]

        # update circles
        for i, (pos, vel) in enumerate(fr):
            circles[i].center = pos

        # update HUD text (pos + vel for each puck)
        lines = []
        for i, (pos, vel) in enumerate(fr):
            x, y = pos
            vx, vy = vel
            lines.append(f"Puck {i+1}:  x={x:+.2f}  y={y:+.2f}   vx={vx:+.2f}  vy={vy:+.2f}")
        hud.set_text("\n".join(lines))

        return circles + [hud]

    anim = FuncAnimation(
        fig,
        update,
        init_func=init,
        frames=len(frames),
        interval=1000 / fps,
        blit=True,
    )

    # Save to a real file path (Pyodide/Matplotlib requires this)
    out_path = "/tmp/sim.gif"
    writer = PillowWriter(fps=fps)
    anim.save(out_path, writer=writer)
    plt.close(fig)

    # Force "no loop" GIF (best-effort across viewers)
    from PIL import Image, ImageSequence
    im = Image.open(out_path)
    seq = [f.copy() for f in ImageSequence.Iterator(im)]
    duration = int(1000 / fps)
    seq[0].save(
        out_path,
        save_all=True,
        append_images=seq[1:],
        duration=duration,
        loop=1,          # many viewers interpret this as "play once"
        disposal=2
    )

    with open(out_path, "rb") as f:
        data = f.read()
    try:
        os.remove(out_path)
    except Exception:
        pass

    return base64.b64encode(data).decode("utf-8")
      `);

      statusEl.textContent = "Redo.";
      simulateBtn.disabled = false;
    }

    simulateBtn.addEventListener("click", () => {
      doSimulate().catch(err => {
        statusEl.textContent = "Fel.";
        simHintEl.textContent = err?.message || String(err);
      });
    });

    async function doSimulate(){
      if (!pyodide) return;
      if (pucks.length === 0){
        statusEl.textContent = "Lägg till åtminstone en puck.";
        return;
      }

      const friction = readNum("friction");
      const T = readNum("T");

      if ([friction, T].some(v => v === null)){
        statusEl.textContent = "Fyll i friction/T med giltiga tal.";
        return;
      }
      if (friction < 0){
        statusEl.textContent = "Friktionen måste vara >= 0.";
        return;
      }
      if (T <= 0){
        statusEl.textContent = "T måste vara > 0.";
        return;
      }

      simulateBtn.disabled = true;
      statusEl.textContent = "Simulerar + renderar GIF…";
      simHintEl.textContent = "Allt sker i Python (Matplotlib).";

      // Pass data to Python
      pyodide.globals.set("pucks_js", pyodide.toPy(pucks));
      pyodide.globals.set("friction_js", friction);
      pyodide.globals.set("T_js", T);

      const b64gif = pyodide.runPython("simulate_to_gif_base64(pucks_js, friction_js, T_js)");

      simAreaEl.innerHTML = `<img alt="Simulation GIF" src="data:image/gif;base64,${b64gif}">`;

      statusEl.textContent = "Klar.";
      simHintEl.textContent = "GIF genererad av Matplotlib.";
      simulateBtn.disabled = false;
    }

    // init
    renderPuckList();
    initPyodideAndPackages().catch(err => {
      statusEl.textContent = "Lyckades inte ladda Python.";
      simHintEl.textContent = err?.message || String(err);
    });
  </script>
</body>
</html>
